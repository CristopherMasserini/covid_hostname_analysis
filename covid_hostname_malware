import requests
from datetime import datetime
import pandas as pd
import whois
import subprocess


# This takes the date and time, combines them and converts it into seconds since the Epoch for easy calculation
# Also puts the hostnames into its list
# date_to_start is the date where you want to start the processing. Useful this is being more than once. This way,
# You do not need to process all the data each time you want to update your data
def processing(text_list: str, date_to_start: str) -> pd.DataFrame:
    seconds_of_record = list()  # The date and time of the hostname creation using Epoch time
    dates_of_record = list()  # The date and time of the hostname creation using date time
    hostnames = list()  # The hostname
    start_index = text_list.index("date,time,hostname")
    for record in text_list[start_index + 1:]:
        try:
            # Splits the record into date, time, and hostname
            record_list = record.split(',')
            record_datetime_str = record_list[0] + " " + record_list[1]  # Concatenates the date and time
            hostname = record_list[2]  # The host name
            record_datetime = datetime.strptime(record_datetime_str, '%Y-%m-%d %H:%M:%S.%f')  # Converts to datetime
            start_date = datetime.strptime(date_to_start, '%Y-%m-%d %H:%M:%S.%f')  # Converts start date to datetime
            record_datetime_seconds = record_datetime.timestamp()  # Puts seconds since Epoch
            start_date_seconds = start_date.timestamp()  # Puts seconds since Epoch
            if record_datetime_seconds >= start_date_seconds:
                seconds_of_record.append(record_datetime_seconds)  # Puts the creation time into a list
                dates_of_record.append(record_datetime)  # Puts the creation time into a list
                hostnames.append(hostname)  # Puts the hostname into a list
        except IndexError:  # Got to the last record in the list
            pass

    # Puts the seconds since Epoch and hostname into a data frame. This is used so it can be sorted by the seconds.
    # This is because at the time of writing this code, not all the data is sorted according to date and time correctly.
    pd.options.display.float_format = '{:10f}'.format
    data = {"Hostname Creation Date": dates_of_record, "Hostname Creation Time": seconds_of_record,
            "Hostname": hostnames}
    df = pd.DataFrame(data)
    df = df.sort_values(by=["Hostname Creation Time"])
    df.index = range(len(df))  # Resets the indexing after the the sorting
    return df


def creation_scoring(df: pd.DataFrame) -> pd.DataFrame:
    # This calculates the difference in time that a host name was created since the last host name creation time.
    time_since_last = list()  # Used to see time between hostname creations
    score = list()  # Used to score the record
    for i in range(0, len(df.loc[:, "Hostname Creation Time"])):
        time_of_record = df.loc[:, "Hostname Creation Time"]
        time = 0.0
        if i == 0:
            time_since_last.append(time)
        else:
            try:
                time = time_of_record[i] - time_of_record[i - 1]
                time_since_last.append(time)
            except IndexError:
                time = time_of_record[i] - time_of_record[i - 1]
                time_since_last.append(time)

        # Create a score. So depending on the time diff column and the amount of time since the base domain was created,
        # the hostname will get a score. Smaller the score, the higher the risk of being malicious.
        # For time difference: less than one second gets a score of 1, between one and 5 seconds gets a score of 5,
        # Between 5 and 10 seconds gets a score of 10, above 10 seconds gets a score of 15
        # I give an intermediate score of 7 for time that equal zero. This is because of the issue that arises outlined
        # In the file of the first hostnames with the same time for date and time. Since it is not known, time cannot be
        # An overwhelming factor in score, right now. Can be fixed in the future
        if time == 0:
            score.append(7)
        elif 0 < time <= 1:
            score.append(1)
        elif 1 < time <= 5:
            score.append(5)
        elif 5 < time <= 10:
            score.append(10)
        else:
            score.append(15)

    # Adds the difference in time and score to the data frame
    df["Time diff"] = time_since_last
    df["Time Score"] = score
    return df


# Gives a score for how ling the base domain has been active. For instance, any hostname with duke.edu base domain
# Will come up with a creation date time of 1986-06-02 00:00:00.
# Less than one year, score is 1, between one year and two years gets a score of 5
# Between two year and five years gets a score of 10, and greater than 5 years gets a score of 10
# Because whois library does not recognize some TLD, like .pt which is the portugal country code TLD,
# Any hostnames with this problem get an intermediate score of 7
def base_domain_scoring(df: pd.DataFrame) -> pd.DataFrame:
    # Assuming a 365 day year and no leap seconds, a good enough calculation
    # score = list(df.loc[:, "Score"])
    score_new = list()

    seconds_in_year = 31536000
    now = datetime.utcnow().timestamp()
    one_year_ago = now - seconds_in_year
    two_years_ago = now - (2 * seconds_in_year)
    five_years_ago = now - (5 * seconds_in_year)

    names = list(df.loc[:, "Hostname"])
    hostname_creation_times = list(df.loc[:, "Hostname Creation Time"])
    for i in range(0, len(names)):
        name = names[i]
        try:
            hostname_creation_time = hostname_creation_times[i]

            # A lot of the hostnames on the list are already base domains, so do not need to look those up
            # Just a way to save time, otherwise it has a really long run time
            if len(name.split('.')) > 2:
                hostname_creation_time = whois.query(name).creation_date.timestamp()

            if hostname_creation_time > one_year_ago:
                score_new.append(1)
            elif two_years_ago < hostname_creation_time <= one_year_ago:
                score_new.append(5)
            elif five_years_ago < hostname_creation_time <= two_years_ago:
                score_new.append(10)
            else:
                score_new.append(15)
        except whois.exceptions.UnknownTld:
            # This is done for the problem described above
            score_new.append(7)
        except AttributeError:
            # Some of the hostnames don't give a creation date
            score_new.append(7)

    df["Base Domain Score"] = score_new

    return df


# Add the IP Address of the hostname to the data frame.
# This can be used to see which hostnames all have the same IP Address
# Many hostnames all with the same IP can be a sign of a phishy domain
def ip_inclusion(df: pd.DataFrame) -> pd.DataFrame:
    # For IP Address lookup
    ip_list = list()
    names = list(df.loc[:, "Hostname"])
    for i in range(0, len(names)):
        cmd = f'nslookup {names[i]} | grep Address: |grep -v -e "#"'
        ps = subprocess.Popen(cmd, shell=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        output = ps.communicate()[0]
        ip = output.split('\n')[0][9:]
        ip_list.append(ip)

    df["IP Addresses"] = ip_list
    return df


# Writes to a csv. Either writing a new file or appending
# df is data to be added
# name is name of file
# selection is if it is to be appended or a new file
def write_csv(df: pd.DataFrame, name: str, selection: str):
    if selection == "append":
        df.to_csv(name, mode='a', header=False, index=False)
    else:
        df.to_csv(name, index=False)


if __name__ == '__main__':
    # Getting the data from the link
    # This then splits the file into individual strings at new line characters
    # Then ignores the description before the data starts
    link = 'https://1984.sh/covid19-domains-feed.txt'
    f = requests.get(link)
    link_text = f.text.split('\n')

    # The date and time to start at
    # 2020-03-14 15:11:20.684411 is the very beginning of the file
    initial_date = "2020-03-14 15:11:20.684411"

    frame = creation_scoring(processing(link_text, initial_date))
    frame_updated = base_domain_scoring(frame.tail(20))
    frame_new = ip_inclusion(frame_updated)

    write_csv(frame_new, r'HostnameData.csv', "write")

