import requests
from datetime import datetime
import pandas as pd
import whois


# This takes the date and time, combines them and converts it into seconds since the Epoch for easy calculation
# Also puts the hostnames into its list
def processing(text_list: str) -> pd.DataFrame:
    seconds_of_record = list()  # The date and time of the hostname creation using Epoch time
    dates_of_record = list()  # The date and time of the hostname creation using date time
    hostnames = list()  # The hostname
    start_index = text_list.index("date,time,hostname")
    for record in text_list[start_index + 1:]:
        try:
            # Splits the record into date, time, and hostname
            record_list = record.split(',')
            record_datetime_str = record_list[0] + " " + record_list[1]  # Concatenates the date and time
            hostname = record_list[2]  # The host name
            record_datetime = datetime.strptime(record_datetime_str, '%Y-%m-%d %H:%M:%S.%f')  # Converts to datetime
            time = record_datetime.timestamp()  # Puts seconds since Epoch
            seconds_of_record.append(time)  # Puts the creation time into a list
            dates_of_record.append(record_datetime)  # Puts the creation time into a list
            hostnames.append(hostname)  # Puts the hostname into a list
        except IndexError:  # Got to the last record in the list
            pass

    # Puts the seconds since Epoch and hostname into a data frame. This is used so it can be sorted by the seconds.
    # This is because at the time of writing this code, not all the data is sorted according to date and time correctly.
    pd.options.display.float_format = '{:10f}'.format
    data = {"Hostname Creation Date": dates_of_record, "Hostname Creation Time": seconds_of_record,
            "Hostname": hostnames}
    df = pd.DataFrame(data)
    df = df.sort_values(by=["Hostname Creation Time"])
    df.index = range(len(df))  # Resets the indexing after the the sorting
    return df


def creation_scoring(df: pd.DataFrame) -> pd.DataFrame:
    # This calculates the difference in time that a host name was created since the last host name creation time.
    time_since_last = list()  # Used to see time between hostname creations
    score = list()  # Used to score the record
    for i in range(0, len(df.loc[:, "Hostname Creation Time"])):
        time_of_record = df.loc[:, "Hostname Creation Time"]
        time = 0.0
        if i == 0:
            time_since_last.append(time)
        else:
            try:
                time = time_of_record[i] - time_of_record[i - 1]
                time_since_last.append(time)
            except IndexError:
                time = time_of_record[i] - time_of_record[i - 1]
                time_since_last.append(time)

        # Create a score. So depending on the time diff column and the amount of time since the base domain was created,
        # the hostname will get a score. Smaller the score, the higher the risk of being malicious.
        # For time difference: less than one second gets a score of 1, between one and 5 seconds gets a score of 5,
        # Between 5 and 10 seconds gets a score of 10, above 10 seconds gets a score of 15
        # I give an intermediate score of 7 for time that equal zero. This is because of the issue that arises outlined
        # In the file of the first hostnames with the same time for date and time. Since it is not known, time cannot be
        # An overwhelming factor in score, right now. Can be fixed in the future
        if time == 0:
            score.append(7)
        elif 0 < time <= 1:
            score.append(1)
        elif 1 < time <= 5:
            score.append(5)
        elif 5 < time <= 10:
            score.append(10)
        else:
            score.append(15)

    # Adds the difference in time and score to the data frame
    df["Time diff"] = time_since_last
    df["Time Score"] = score
    return df


# Gives a score for how ling the base domain has been active. For instance, any hostname with duke.edu base domain
# Will come up with a creation date time of 1986-06-02 00:00:00.
# Less than one year, score is 1, between one year and two years gets a score of 5
# Between two year and five years gets a score of 10, and greater than 5 years gets a score of 10
# Because whois library does not recognize some TLD, like .pt which is the portugal country code TLD,
# Any hostnames with this problem get an intermediate score of 7
def base_domain_scoring(df: pd.DataFrame) -> pd.DataFrame:
    # Assuming a 365 day year and no leap seconds, a good enough calculation
    # score = list(df.loc[:, "Score"])
    score_new = list()

    seconds_in_year = 31536000
    now = datetime.utcnow().timestamp()
    one_year_ago = now - seconds_in_year
    two_years_ago = now - (2 * seconds_in_year)
    five_years_ago = now - (5 * seconds_in_year)

    names = list(df.loc[:, "Hostname"])
    hostname_creation_times = list(df.loc[:, "Hostname Creation Time"])
    for i in range(0, len(names)):
        name = names[i]
        try:
            hostname_creation_time = hostname_creation_times[i]

            # A lot of the hostnames on the list are already base domains, so do not need to look those up
            # Just a way to save time, otherwise it has a really long run time
            if len(name.split('.')) > 2:
                hostname_creation_time = whois.query(name).creation_date.timestamp()

            if hostname_creation_time > one_year_ago:
                score_new.append(1)
            elif two_years_ago < hostname_creation_time <= one_year_ago:
                score_new.append(5)
            elif five_years_ago < hostname_creation_time <= two_years_ago:
                score_new.append(10)
            else:
                score_new.append(15)
        except whois.exceptions.UnknownTld:
            # This is done for the problem described above
            score_new.append(7)
        except AttributeError:
            # Some of the hostnames don't give a creation date
            score_new.append(7)

    df["Base Domain Score"] = score_new

    return df


if __name__ == '__main__':
    # Getting the data from the link
    # This then splits the file into individual strings at new line characters
    # Then ignores the description before the data starts
    link = 'https://1984.sh/covid19-domains-feed.txt'
    f = requests.get(link)
    link_text = f.text.split('\n')

    frame = creation_scoring(processing(link_text))
    frame_updated = base_domain_scoring(frame)

    frame_updated.to_csv(r'HostnameData.csv', index=False)
